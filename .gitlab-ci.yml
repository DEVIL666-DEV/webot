# .gitlab-ci.yml

stages:
  - sync
  - test

variables:
  GITHUB_REPO_URL: "https://github.com/whiteout-project/bot.git"
  GIT_STRATEGY: none
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"

sync_from_github:
  stage: sync
  image:
    name: alpine/git:latest
    entrypoint: [""]
  tags:
    - docker
  script:
    - echo "Starting clean-room sync..."
    - git clone --mirror $GITHUB_REPO_URL .
    - git push --mirror "https://gitlab-ci:${GITLAB_PUSH_TOKEN}@${CI_PROJECT_URL#https://}"
    - echo "Sync complete."
  rules:
    - if: '$CI_PIPELINE_SOURCE == "trigger"'

# Docker-based test with update (Debian base)
test-bot-docker-update:
  stage: test
  image: python:3.12-slim-bookworm
  tags:
    - docker
  cache:
    paths:
      - .cache/pip
  variables:
    GIT_STRATEGY: clone
    PIP_VERBOSE: "1"
    PIP_NO_CACHE_DIR: "1"
  before_script:
    - apt-get update && apt-get install -y git procps sqlite3
    - python --version
    - python -m pip --version || echo "pip not available"
    - python -c "import sys; print('Python executable:', sys.executable)"
    - python -c "import site; print('Site packages:', site.getsitepackages())" || echo "Cannot get site packages"
    - python -m pip install wheel || echo "pip install test failed"
    # Initialize admin database
    - mkdir -p db
    - |
      if [ -n "$CI_ADMIN_USER_ID" ]; then
        sqlite3 db/settings.sqlite << EOF
        CREATE TABLE IF NOT EXISTS admin (
            id INTEGER PRIMARY KEY,
            is_initial INTEGER
        );
        CREATE TABLE IF NOT EXISTS auto (
            value INTEGER
        );
        INSERT INTO admin (id, is_initial) VALUES ($CI_ADMIN_USER_ID, 1);
        INSERT INTO auto (value) VALUES (1);
      EOF
        echo "Admin database initialized with user ID: $CI_ADMIN_USER_ID"
      else
        echo "Warning: CI_ADMIN_USER_ID not set, bot will wait for manual setup"
      fi
  script:
    - echo "Testing bot startup in Docker with updates (Debian)..."
    - echo "$CI_BOT_TOKEN" > bot_token.txt
    - echo "=== Current directory $(pwd) ==="
    - echo "=== Directory contents ==="
    - ls -la
    - echo "=== Python files ==="
    - find . -name "*.py" -type f | head -20
    - |
      if [ ! -f main.py ]; then
        echo "ERROR: main.py not found!"
        exit 1
      fi
    - head -n 5 main.py
    - python -m py_compile main.py || echo "Python syntax error in main.py"
    - |
      echo "=== Running bot in foreground with timeout ==="
      echo "The bot will run until it logs in successfully or timeout occurs"
      # Create a wrapper script to check for success
      cat > check_bot_success.sh << 'EOF'
      #!/bin/bash
      LOG_FILE="bot_output.log"
      TIMEOUT=300
      START_TIME=$(date +%s)
      
      # Start the bot and tee output to log file
      python -u main.py 2>&1 | tee $LOG_FILE &
      BOT_PID=$!
      
      echo "Bot started with PID: $BOT_PID"
      
      while true; do
        CURRENT_TIME=$(date +%s)
        ELAPSED=$((CURRENT_TIME - START_TIME))
        
        if [ $ELAPSED -gt $TIMEOUT ]; then
          echo "Timeout after $TIMEOUT seconds"
          kill $BOT_PID 2>/dev/null || true
          exit 1
        fi
        
        # Check if bot process is still running
        if ! ps -p $BOT_PID > /dev/null 2>&1; then
          echo "Bot process has exited"
          wait $BOT_PID
          EXIT_CODE=$?
          
          # Check if it was a restart
          if grep -q "Restarting bot..." $LOG_FILE; then
            echo "Bot restarted after update - this is normal"
            # The bot will restart itself, so this script exits successfully
            exit 0
          else
            echo "Bot exited with code: $EXIT_CODE"
            exit $EXIT_CODE
          fi
        fi
        
        # Check for success indicators
        if grep -q "✓ All requirements satisfied" $LOG_FILE && \
           grep -q "✓ All core imports successful" $LOG_FILE && \
           grep -q "Logged in as" $LOG_FILE && \
           grep -q "Activation messages sent to admin user." $LOG_FILE; then
          echo "Bot initialization successful!"
          sleep 5  # Let it run a bit more
          kill $BOT_PID 2>/dev/null || true
          exit 0
        fi
        
        # Show progress
        if [ $((ELAPSED % 10)) -eq 0 ] && [ $ELAPSED -gt 0 ]; then
          echo "Still waiting... ($ELAPSED/$TIMEOUT seconds)"
        fi
        
        sleep 1
      done
      EOF
      
      chmod +x check_bot_success.sh
      ./check_bot_success.sh
  after_script:
    - echo "=== Final Bot Output ==="
    - cat bot_output.log || true
    - echo "=== Gift Solver Log ==="
    - cat log/gift_solver.txt || true
  artifacts:
    when: always
    paths:
      - bot_output.log
      - log/
    expire_in: 1 week
  rules:
    - if: '$CI_PIPELINE_SOURCE == "trigger"'
      when: on_success
    - if: '$CI_PIPELINE_SOURCE == "push"'
      changes:
        - "**/*.py"
        - ".gitlab-ci.yml"
        - "requirements.txt"

# Linux native test with update (Debian runner)
test-bot-linux-update:
  stage: test
  tags:
    - shell
  cache:
    paths:
      - .cache/pip
      - bot_venv/
  variables:
    GIT_STRATEGY: clone
  before_script:
    - python3 --version
    - echo "Creating virtual environment to bypass system restrictions..."
    - python3 -m venv bot_venv
    - source bot_venv/bin/activate
    - python --version
    - pip --version
    - python -c "import sys; print('Python executable:', sys.executable)"
    - pip install --upgrade pip wheel
    - echo "Virtual environment ready"
    # Initialize admin database
    - mkdir -p db
    - |
      if [ -n "$CI_ADMIN_USER_ID" ]; then
        sqlite3 db/settings.sqlite << EOF
        CREATE TABLE IF NOT EXISTS admin (
            id INTEGER PRIMARY KEY,
            is_initial INTEGER
        );
        CREATE TABLE IF NOT EXISTS auto (
            value INTEGER
        );
        INSERT INTO admin (id, is_initial) VALUES ($CI_ADMIN_USER_ID, 1);
        INSERT INTO auto (value) VALUES (1);
      EOF
        echo "Admin database initialized with user ID: $CI_ADMIN_USER_ID"
      else
        echo "Warning: CI_ADMIN_USER_ID not set, bot will wait for manual setup"
      fi
  script:
    - source bot_venv/bin/activate
    - echo "Testing bot startup on Linux with updates (native)..."
    - echo "$CI_BOT_TOKEN" > bot_token.txt
    
    - |
      python main.py --no-venv --autoupdate > bot_output.log 2> bot_error.log &
      BOT_PID=$!
      echo $BOT_PID > .bot_pid
      
      TIMEOUT=300
      START_TIME=$(date +%s)
      RESTART_DETECTED=false
      
      while true; do
        CURRENT_TIME=$(date +%s)
        ELAPSED=$((CURRENT_TIME - START_TIME))
        
        if [ $ELAPSED -gt $TIMEOUT ]; then
          echo "Timeout waiting for bot initialization"
          kill $BOT_PID 2>/dev/null || true
          echo "=== STDOUT ==="
          cat bot_output.log
          echo "=== STDERR ==="
          cat bot_error.log || true
          exit 1
        fi
        
        if ! ps -p $BOT_PID > /dev/null; then
          echo "Bot process terminated unexpectedly"
          echo "=== STDOUT ==="
          cat bot_output.log
          echo "=== STDERR ==="
          cat bot_error.log || true
          exit 1
        fi
        
        # Check error log for pip failures
        if [ -f bot_error.log ] && [ -s bot_error.log ]; then
          if grep -q "pip" bot_error.log || grep -q "Failed to install" bot_error.log; then
            echo "=== PIP ERROR DETECTED ==="
            cat bot_error.log
          fi
        fi
        
        # Check for bot restart (happens after auto-update)
        if grep -q "Restarting bot..." bot_output.log && [ "$RESTART_DETECTED" != "true" ]; then
          echo "Bot is restarting after update - waiting for new process..."
          RESTART_DETECTED=true
          sleep 5
          
          # Find the new python process running main.py
          NEW_PID=$(ps aux | grep "[p]ython.*main.py.*--no-venv.*--autoupdate" | grep -v grep | awk '{print $2}' | head -1)
          if [ -n "$NEW_PID" ]; then
            echo "Found new bot process with PID: $NEW_PID"
            BOT_PID=$NEW_PID
            echo $BOT_PID > .bot_pid
          else
            echo "Warning: Could not find new bot process after restart"
          fi
          
          # Continue waiting for actual success
          continue
        fi
        
        if grep -q "✓ All requirements satisfied" bot_output.log && \
           grep -q "✓ All core imports successful" bot_output.log && \
           grep -q "Logged in as" bot_output.log && \
           grep -q "Activation messages sent to admin user." bot_output.log; then
          echo "Bot initialization successful!"
          break
        fi
        
        # Show progress every 10 seconds
        if [ $((ELAPSED % 10)) -eq 0 ] && [ $ELAPSED -gt 0 ]; then
          echo "Still waiting for bot initialization... ($ELAPSED/$TIMEOUT seconds)"
        fi
        
        sleep 1
      done
      
      echo "=== Bot started successfully ==="
      grep "Logged in as" bot_output.log
      grep "Activation messages" bot_output.log
  after_script:
    - |
      if [ -f .bot_pid ]; then
        kill $(cat .bot_pid) 2>/dev/null || true
        sleep 2
        kill -9 $(cat .bot_pid) 2>/dev/null || true
      fi
    - echo "=== Final Logs (STDOUT) ==="
    - cat bot_output.log || true
    - echo "=== Error Log (STDERR) ==="
    - cat bot_error.log || true
    - echo "=== Gift Solver Log ==="
    - cat log/gift_solver.txt || true
  artifacts:
    when: always
    paths:
      - bot_output.log
      - bot_error.log
      - log/
    expire_in: 1 week
  rules:
    - if: '$CI_PIPELINE_SOURCE == "trigger"'
      when: on_success
    - if: '$CI_PIPELINE_SOURCE == "push"'
      changes:
        - "**/*.py"
        - ".gitlab-ci.yml"
        - "requirements.txt"

# Docker-based test without update (Debian base)
test-bot-docker-no-update:
  stage: test
  image: python:3.12-slim-bookworm
  tags:
    - docker
  cache:
    paths:
      - .cache/pip
  variables:
    GIT_STRATEGY: clone
    PIP_VERBOSE: "1"
    PIP_NO_CACHE_DIR: "1"
  before_script:
    - apt-get update && apt-get install -y git procps sqlite3
    - python --version
    - python -m pip --version || echo "pip not available"
    - python -c "import sys; print('Python executable:', sys.executable)"
    - python -c "import site; print('Site packages:', site.getsitepackages())" || echo "Cannot get site packages"
    - python -m pip install wheel || echo "pip install test failed"
    # Initialize admin database
    - mkdir -p db
    - |
      if [ -n "$CI_ADMIN_USER_ID" ]; then
        sqlite3 db/settings.sqlite << EOF
        CREATE TABLE IF NOT EXISTS admin (
            id INTEGER PRIMARY KEY,
            is_initial INTEGER
        );
        CREATE TABLE IF NOT EXISTS auto (
            value INTEGER
        );
        INSERT INTO admin (id, is_initial) VALUES ($CI_ADMIN_USER_ID, 1);
        INSERT INTO auto (value) VALUES (1);
      EOF
        echo "Admin database initialized with user ID: $CI_ADMIN_USER_ID"
      else
        echo "Warning: CI_ADMIN_USER_ID not set, bot will wait for manual setup"
      fi
  script:
    - echo "Testing bot startup in Docker without updates (Debian)..."
    - echo "$CI_BOT_TOKEN" > bot_token.txt
    - echo "=== Current directory $(pwd) ==="
    - echo "=== Directory contents ==="
    - ls -la
    - echo "=== Python files ==="
    - find . -name "*.py" -type f | head -20
    - |
      if [ ! -f main.py ]; then
        echo "ERROR: main.py not found!"
        exit 1
      fi
    - head -n 5 main.py
    - python -m py_compile main.py || echo "Python syntax error in main.py"
    - |
      echo "=== Running bot in foreground with --no-update flag ==="
      echo "The bot will run until it logs in successfully or timeout occurs"
      # Create a wrapper script to check for success
      cat > check_bot_success.sh << 'EOF'
      #!/bin/bash
      LOG_FILE="bot_output.log"
      TIMEOUT=180
      START_TIME=$(date +%s)
      
      # Start the bot and tee output to log file
      python -u main.py --no-update 2>&1 | tee $LOG_FILE &
      BOT_PID=$!
      
      echo "Bot started with PID: $BOT_PID"
      
      while true; do
        CURRENT_TIME=$(date +%s)
        ELAPSED=$((CURRENT_TIME - START_TIME))
        
        if [ $ELAPSED -gt $TIMEOUT ]; then
          echo "Timeout after $TIMEOUT seconds"
          kill $BOT_PID 2>/dev/null || true
          exit 1
        fi
        
        # Check if bot process is still running
        if ! ps -p $BOT_PID > /dev/null 2>&1; then
          echo "Bot process has exited"
          wait $BOT_PID
          EXIT_CODE=$?
          echo "Bot exited with code: $EXIT_CODE"
          exit $EXIT_CODE
        fi
        
        # Check for success indicators
        if grep -q "Update check skipped due to --no-update flag" $LOG_FILE && \
           grep -q "✓ All requirements satisfied" $LOG_FILE && \
           grep -q "✓ All core imports successful" $LOG_FILE && \
           grep -q "Logged in as" $LOG_FILE && \
           grep -q "Activation messages sent to admin user." $LOG_FILE; then
          echo "Bot initialization successful!"
          sleep 5  # Let it run a bit more
          kill $BOT_PID 2>/dev/null || true
          exit 0
        fi
        
        # Show progress
        if [ $((ELAPSED % 10)) -eq 0 ] && [ $ELAPSED -gt 0 ]; then
          echo "Still waiting... ($ELAPSED/$TIMEOUT seconds)"
        fi
        
        sleep 1
      done
      EOF
      
      chmod +x check_bot_success.sh
      ./check_bot_success.sh
  after_script:
    - echo "=== Final Bot Output ==="
    - cat bot_output.log || true
    - echo "=== Gift Solver Log ==="
    - cat log/gift_solver.txt || true
  artifacts:
    when: always
    paths:
      - bot_output.log
      - log/
    expire_in: 1 week
  rules:
    - if: '$CI_PIPELINE_SOURCE == "trigger"'
      when: on_success
    - if: '$CI_PIPELINE_SOURCE == "push"'
      changes:
        - "**/*.py"
        - ".gitlab-ci.yml"
        - "requirements.txt"

# Linux native test without update (Debian runner)
test-bot-linux-no-update:
  stage: test
  tags:
    - shell
  cache:
    paths:
      - .cache/pip
      - bot_venv/
  variables:
    GIT_STRATEGY: clone
  before_script:
    - python3 --version
    - echo "Creating virtual environment to bypass system restrictions..."
    - python3 -m venv bot_venv
    - source bot_venv/bin/activate
    - python --version
    - pip --version
    - python -c "import sys; print('Python executable:', sys.executable)"
    - pip install --upgrade pip wheel
    - echo "Virtual environment ready"
    # Initialize admin database
    - mkdir -p db
    - |
      if [ -n "$CI_ADMIN_USER_ID" ]; then
        sqlite3 db/settings.sqlite << EOF
        CREATE TABLE IF NOT EXISTS admin (
            id INTEGER PRIMARY KEY,
            is_initial INTEGER
        );
        CREATE TABLE IF NOT EXISTS auto (
            value INTEGER
        );
        INSERT INTO admin (id, is_initial) VALUES ($CI_ADMIN_USER_ID, 1);
        INSERT INTO auto (value) VALUES (1);
      EOF
        echo "Admin database initialized with user ID: $CI_ADMIN_USER_ID"
      else
        echo "Warning: CI_ADMIN_USER_ID not set, bot will wait for manual setup"
      fi
  script:
    - source bot_venv/bin/activate
    - echo "Testing bot startup on Linux without updates (native)..."
    - echo "$CI_BOT_TOKEN" > bot_token.txt
    
    - |
      python main.py --no-venv --no-update 2>&1 | tee bot_output.log &
      BOT_PID=$!
      echo $BOT_PID > .bot_pid
      
      TIMEOUT=180
      START_TIME=$(date +%s)
      
      while true; do
        CURRENT_TIME=$(date +%s)
        ELAPSED=$((CURRENT_TIME - START_TIME))
        
        if [ $ELAPSED -gt $TIMEOUT ]; then
          echo "Timeout waiting for bot initialization"
          kill $BOT_PID 2>/dev/null || true
          echo "=== STDOUT ==="
          cat bot_output.log
          exit 1
        fi
        
        if ! ps -p $BOT_PID > /dev/null; then
          echo "Bot process terminated unexpectedly"
          echo "=== STDOUT ==="
          cat bot_output.log
          exit 1
        fi
        
        if grep -q "Update check skipped due to --no-update flag" bot_output.log && \
           grep -q "✓ All requirements satisfied" bot_output.log && \
           grep -q "✓ All core imports successful" bot_output.log && \
           grep -q "Logged in as" bot_output.log && \
           grep -q "Activation messages sent to admin user." bot_output.log; then
          echo "Bot initialization successful!"
          break
        fi
        
        # Show progress every 10 seconds
        if [ $((ELAPSED % 10)) -eq 0 ] && [ $ELAPSED -gt 0 ]; then
          echo "Still waiting for bot initialization... ($ELAPSED/$TIMEOUT seconds)"
        fi
        
        sleep 1
      done
      
      echo "=== Bot started successfully ==="
      grep "Logged in as" bot_output.log
      grep "Activation messages" bot_output.log
      grep "Update check skipped" bot_output.log
  after_script:
    - |
      if [ -f .bot_pid ]; then
        kill $(cat .bot_pid) 2>/dev/null || true
        sleep 2
        kill -9 $(cat .bot_pid) 2>/dev/null || true
      fi
    - echo "=== Final Logs (STDOUT) ==="
    - cat bot_output.log || true
    - echo "=== Gift Solver Log ==="
    - cat log/gift_solver.txt || true
  artifacts:
    when: always
    paths:
      - bot_output.log
      - log/
    expire_in: 1 week
  rules:
    - if: '$CI_PIPELINE_SOURCE == "trigger"'
      when: on_success
    - if: '$CI_PIPELINE_SOURCE == "push"'
      changes:
        - "**/*.py"
        - ".gitlab-ci.yml"
        - "requirements.txt"